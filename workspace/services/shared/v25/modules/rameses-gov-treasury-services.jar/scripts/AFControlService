import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

class AFControlService {

	@PersistenceContext("main")
	def em;

	@Service("AFControlPostService")
	def postSvc;
	
	@Service("DateService")
	def dateSvc;
	
	@Env
	def env;
	
	
	
	/**
	* this routine tests the series to check for conflicts until none is found. 
	* Routine: Check if there are conflicts if a conflict is returned, get the first value,
	* then get the endseries. Add 1 and test again until no records are returned
	*/
	@ProxyMethod
	public int findNextAvailableSeries( def m ) {
		def z = [controlid: m.controlid, startseries:m.series,endseries:m.series];
		def conflictQry = em.sqlContext.createNamedQuery("afcontrol:getConflictSeries");
		def result = conflictQry.setParameters(z).singleResult;
		if( !result ) {
			return m.series;
		}	
		else {
			m.series = result.endseries + 1;
			return findNextAvailableSeries( m );
		}	
	}
	
	
	/** 
	* there is only one active control for the collector. called when there are no active
	* parameters : collectorid, af
	*/
	@ProxyMethod
	public def findActiveControlId( def o ) {
		if(!o.af) throw new Exception("Please specify af");
		if(!o.userid) throw new Exception("Please specify userid");
		return em.sqlContext.createNamedQuery("afcontrol:findActiveControlId").setParameters(o).singleResult;
	}
	
	/** 
	* called when the controlid is established. A collector needs to get first the active stub
	*/
	@ProxyMethod
	public def getNextReceiptInfo( def o ) {
		if( !o.objid ) throw new Exception( "getNextReceiptInfo requires an objid parameter");
	
		def m = em.sqlContext.createNamedQuery("afcontrol:getNextReceiptInfo").setParameters(o).singleResult;
		if(!m) {
			throw new Exception("No receipts available.");
		}	
		def sb = new StringBuilder();
		if(m.prefix) sb.append( m.prefix + "-" );
		sb.append( 	m.series );
		if(m.suffix) sb.append( "-" + m.suffix );
		m.receiptno = sb.toString();
		return m;
	}
	
	
	@ProxyMethod
	public def getOpenControlList( def o ) {
		if(!o.af) throw new Exception("AFControlService.getOpenControlList requires af parameter");
		o.userid = env.USERID;
		return em.sqlContext.createNamedQuery("afcontrol:getOpenControlList").setParameters( o ).resultList;
	}
	
	@ProxyMethod
	public void activateControl( def o ) {
		if(!o.objid) throw new Exception("AFControlService.activateControl requires objid parameter");
		em.sqlContext.createNamedExecutor("afcontrol:activateControl").setParameters( o ).execute();
	}
	
	@ProxyMethod
	public void deactivateControl( def o ) {
		if(!o.objid) throw new Exception("AFControlService.deactivateControl requires objid parameter");
		em.sqlContext.createNamedExecutor("afcontrol:deactivateControl").setParameters( o ).execute();
	}
	
	@ProxyMethod
	public void shiftActivateControl( def o ) {
		if(!o.previd) throw new Exception("AFControlService.shiftActivateControl requires previd parameter");
		if(!o.objid) throw new Exception("AFControlService.shiftActivateControl requires objid parameter");
		em.sqlContext.createNamedExecutor("afcontrol:deactivateControl").setParameters( [objid:o.previd] ).execute();
		em.sqlContext.createNamedExecutor("afcontrol:activateControl").setParameters( [objid:o.objid] ).execute();
	}
	
	@ProxyMethod
	public void transfer( def o ) {
		if(!o.issueto) throw new Exception("AFControlService.transfer requires issueto");
		
		//since most of the time usergroup is job title but required info is only title, so we need to correct.
		if(!o.issueto.title) o.issueto.title = o.issueto.jobtitle;
		o.refdate = dateSvc.serverDate;
		postSvc.postTransfer( o );
	}	
	
	@ProxyMethod
	public void changeMode( def o ) {
		em.sqlContext.createNamedExecutor("afcontrol:changeMode").setParameters(o).execute();
	}	
	
	@ProxyMethod
	public void cancelSeries( def o ) {
		println "cancel series " + o;
		postSvc.postCancel( [controlid:o.objid] );
	}	
	
	@ProxyMethod
	public def getDetailsList( def o ) {
		return em.sqlContext.createNamedQuery("afcontrol:getDetailsList").setParameters(o).resultList;
	}	

	
}
